
metavar var, x, n ::= {{ com term variable }}
{{ isa string}} {{ coq nat}} {{ hol string}} {{ lem string }} {{ coq-equality }}
{{ ocaml int}} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}


grammar

terminals :: 'terminals_' ::=
  | \            ::   :: lambda  {{ tex \lambda }}
  | -->          ::   :: red     {{ tex \longrightarrow }}
  | ==> :: :: bred {{ tex \Longrightarrow }}
%  | ->          ::   :: func     {{ tex \rightarrow }}
%  | ->c          ::   :: funcc   {{ tex \rightarrow_{[c]} }}
%  | >x :: :: arrowx {{ tex \overrightarrow{x} }}
%  | >t :: :: arrowt {{ tex \overrightarrow{t} }}
%  | >tau :: :: arrowtau {{ tex \overrightarrow{\tau} }}
%  | <- :: :: assign {{ tex \leftarrow }}
%  | forall :: :: forall {{ tex \forall }}
%  | alphac :: :: alphac {{ tex \alpha_{c} }}
%  | sigma :: :: sigma {{ tex \sigma }}
%  | tau :: :: tau {{ tex \tau }}
%  | exists :: :: exists {{ tex \exists }}
  | >a :: :: args {{ tex \overline{a} }}
  | >f :: :: formals {{ tex \overline{f} }}
  | >n :: :: nums {{ tex \overline{n} }}
  | >s :: :: strs {{ tex \overline{s} }}
  | >v :: :: addresses {{ tex \overline{\nu} }}
  | empty :: :: empty {{ tex \emptyset }}
  | dpn :: :: doublepointn {{ tex :_{n} }}
  | and :: :: conj {{ tex \land }}
  | seq :: :: seq {{ tex \vdash }}
  | i :: :: frame_address {{ tex \iota }}
  | d :: :: promise_address {{ tex \delta }}
  | v :: :: data_object_address {{ tex \nu }}
  | v_opt :: :: possibly_missing_data_object_address {{ tex \nu_{\bot} }}
  | env :: :: environment {{ tex \Gamma }}
  | primv :: :: primitive_value{{ tex \kappa }}
  | attr :: :: attribute {{ tex \alpha }}
  | primvattr :: :: primitive_value_with_attributes {{ tex \kappa^{\alpha} }}
  | cc :: :: context {{ tex \mathbb{ C } }}
  | rr :: :: context_ret {{ tex \mathbb{ R } }}

e :: 'e_' ::=
  | n :: :: numlit
  | s :: :: strlit
  | x :: :: var
  | x[[e]] :: :: array_access
  | {e; e} :: :: block
  | function( >f ) e :: :: function_decl
  | x( >a ) :: :: function_call
  | x <- e :: :: assignment
  | x <<- e :: :: supassignment
  | x[[e]] <- e :: :: array_assignment
  | x[[e]] <<- e :: :: array_superassignment
  | attr(e,e) :: :: attribute_extraction
  | attr(e,e) <- e :: :: attribute_assignment
  | u :: :: value
  | v ( >a ) :: :: partially_reduced_function_calls
  
f :: 'f_' ::=
  | x :: :: var
  | x = e :: :: var_dft

a :: 'a_' ::=
  | x :: :: var
  | x = e :: :: var_dft


H :: 'H_' ::=
  | empty :: :: empty_heap
  | H[ i /F] :: :: heap_frame_mapping
  | H[ d / e env ] :: :: heap_promise_mapping
  | H[ v / primvattr ] :: :: heap_primitive_value_mapping

attr {{ tex \alpha }} :: 'attr_' ::=
  | v_opt v_opt :: :: attribute_pair

u :: 'u_' ::=
  | d :: :: promise_address
  | v :: :: data_object_address

primv {{ tex \kappa }} :: 'primv_' ::=
  | num[ >n ] :: :: num_array
  | str[ >s ] :: :: str_array
  | gen[ >v ] :: :: addr_array
  | \ >f . e, env :: :: closure

frame {{ tex F }} :: 'frame_' ::=
  | [] :: :: empty_frame
  | F[x/u] :: :: frame_binding

closure_env {{ tex \Gamma }} :: 'closure_env_' ::=
  | [] :: :: empty_env
  | i * env :: :: frame_address

expression_stack {{ tex S }} :: 'expression_stack_' ::=
  | [] :: :: empty_stack
  | e env * S :: :: stack






typescheme, sigma {{ tex \sigma }} :: 'tyscheme_' ::=
  | forall alpha . sigma :: :: gentvar
  | forall alphac . sigma :: ::  gencvar
  | tau :: :: ty

constraint, c :: 'cs_' ::=
  | alphac :: :: cvar
  | exists x dpn tau :: :: exists
  | c and c' :: :: conjonction

type, tau {{ tex  \tau }} :: 'ty_' ::=
  | alpha :: :: type
  | ( >tau ) ->c tau' :: :: arrowty

G {{ tex \Gamma }}  :: 'env_' ::=
  | x : sigma , G :: :: bind_env
  | alpha , G :: :: tvar_env
  | alphac , G :: :: cvar_env
  | empty :: :: empty_env


%v :: 'v_' ::= 
%  | \ ( >a ) . t :: :: lam
%  | TRUE :: :: true
%  | FALSE :: :: false
%  | n :: :: numerics


state, st :: 's_' ::=
| S * H :: :: truc

rr {{ tex \mathbb{ R } }} :: 'rr_' ::=
| [] :: :: empty_context
| { v ; rr } :: :: add_context
  
cc {{ tex \mathbb{ C } }} :: 'cc_' ::=
| x <- __ :: :: assignment_context
%| x [[ __ ]] :: :: subset_context
%| x [[ e ]] <- __ :: :: subset_assignment_context
%| x [[ __ ]] <- v :: :: subset_assignment_context2
%| { __ ; e } :: :: sequence_context
%| { v ; __ } :: :: sequence_context2

contextrules
cc _:: e :: e

%subrules
%  v <:: e

defns
Red :: '' ::=

defn
expression_stack ; H ==> expression_stack' ; H' :: ::reduce::'' by


---------------- :: exp2
cc [e] env ; empty ==> expression_stack' ; empty

----------------------- :: exp
expression_stack ; empty ==> expression_stack' ; empty


-------------------------- :: RetF2
v ( >a) env * S ; H  ==> expression_stack' ; H'

-------------------------- :: RetF
e env * S ; H  ==> expression_stack' ; H'

defn
e env ; H --> e' ; H' :: ::ereduce::'' by

%fake rule

---------------- :: eexp
e env ; H --> e' ; H'